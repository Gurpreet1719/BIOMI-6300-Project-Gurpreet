---
title: "Between Sample (Beta) Diversity of Microbes along a Salinity Gradient"
author: "Gurpreet Kaur"
date: "`r Sys.Date()`"
output: html_documentoutput:
  html_document: 
    code_folding: show
    theme: spacelab
    highlight: pygments
    keep_md: no
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
      toc_depth: 3
  keep_md: true  
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      fig.path = "../figures/05_CommunityAnalysis")
```

# Goals 

1. Load in phyloseq data with rooted tree.  
2. Evaluate sequencing depth and remove sample.  
3. Normalize the read counts between samples.  
4. Calculate community dissimilarities. Numbers between 0 and 1. If 0, completely similar versus if they are 1, then they're completely dissimilar.   
    a. **Sorensen**: Shared Species as a binary value: Abundance-unweighted 
    b. **Bray-Curtis**: Shared Abundant species: Abundance-weighted
    c. **(Abundance-)Weighted UNIFRAC**: Consider Abundant Species and where they fall on the tree  
5. Visualize the community data with two unconstrained Ordinations:  
    a. **PCoA**: Linear Method. Eigenvalue = how much variation is explained by each axis. Choose to view axis 1, 2, 3, etc. and plot them together.  
    b. **NMDS**: Non-linear. Smush multiple Dimensions into 2 or 3 axes. Need to report Stress value (ideally <0.15).  
6. Run statistics with PERMANOVA and betadispR.

# Setup 

## Set the seed 
```{r set-seed}
# Any number can be chosen 
set.seed(238427)
```

## Load Libraries
```{r load-libraries}
#install.packages("vegan")
pacman::p_load(tidyverse, devtools, phyloseq, patchwork, vegan,
               install = FALSE)

# Setting colors for treatments
treatment_colors <- c(
  "N0" = "dodgerblue4",
  "N120" = "brown3",
  "N180" = "darkolivegreen4",
  "N240" = "deeppink4",
  "N360" = "goldenrod4")
```



## Load Data 
```{r load-physeq}
# Load in rooted phylogenetic tree! 
load("data/03_Phylogenetic_Tree/phytree_preprocessed_physeq.RData")
midroot_physeq
unrooted_physeq
```

# Explore Read Counts 

## Raw read depth 
```{r calc-seq-depth}
# Calculate the total number of reads per sample. 
raw_TotalSeqs_df  <- 
  midroot_physeq %>%
  # calculate the sample read sums 
  sample_sums() %>%
  data.frame()
# name the column 
colnames(raw_TotalSeqs_df)[1] <- "TotalSeqs"
  
head(raw_TotalSeqs_df)

# make histogram of raw reads 
raw_TotalSeqs_df %>%
  ggplot(aes(x = TotalSeqs)) + 
  geom_histogram(bins = 50) + 
  scale_x_continuous(limits = c(0, 50000)) + 
  labs(title = "Raw Sequencing Depth Distribution") + 
  theme_classic()
```


## Remove lowly seq sample 
```{r low-seq-sample}
raw_rooted_physeq <- 
  midroot_physeq %>%
  # remove lowly seq sample that was outlier in alpha diversity analysis
  subset_samples(names != "SRR11364374") %>%
  # any asvs unique to this sample will also be removed 
  prune_taxa(taxa_sums(.) > 0, .)

# Inspect 
raw_rooted_physeq

# what is the minimum number of sequences 
raw_rooted_physeq %>%
  sample_sums() %>%
  min()
```

## Normalize read counts  
```{r scale-reads}
### scale_reads function
#################################################################################### 
# Function to scale reads: http://deneflab.github.io/MicrobeMiseq/ 
# Scales reads by 
# 1) taking proportions
# 2) multiplying by a given library size of n
# 3) rounding 
# Default for n is the minimum sample size in your library
# Default for round is floor

matround <- function(x){trunc(x+0.5)}

scale_reads <- function(physeq, n = min(sample_sums(physeq)), round = "round") {
  
  # transform counts to n
  physeq.scale <- transform_sample_counts(physeq, function(x) {(n * x/sum(x))})
  
  # Pick the rounding functions
  if (round == "floor"){
    otu_table(physeq.scale) <- floor(otu_table(physeq.scale))
  } else if (round == "round"){
    otu_table(physeq.scale) <- round(otu_table(physeq.scale))
  } else if (round == "matround"){
    otu_table(physeq.scale) <- matround(otu_table(physeq.scale))
  }
  
  # Prune taxa and return new phyloseq object
  physeq.scale <- prune_taxa(taxa_sums(physeq.scale) > 0, physeq.scale)
  return(physeq.scale)
}
```


## Scale the reads and check the distribution of the seq depth 

This is where one might decide use rarefaction to normalize data. 
```{r scale-physeq}
min(sample_sums(raw_rooted_physeq))

# Scale reads by the above function
scaled_rooted_physeq <- 
  raw_rooted_physeq %>%
  scale_reads(round = "matround")

# Calculate the read depth 
scaled_TotalSeqs_df <- 
  scaled_rooted_physeq %>%
  sample_sums() %>%
  data.frame()
colnames(scaled_TotalSeqs_df)[1] <-"TotalSeqs"

# Inspect
head(scaled_TotalSeqs_df)

# Check the range of the data 
min_seqs <- min(scaled_TotalSeqs_df$TotalSeqs); min_seqs
max_seqs <- max(scaled_TotalSeqs_df$TotalSeqs); max_seqs
# range
max_seqs - min_seqs

# Plot Histogram 
scaled_TotalSeqs_df %>%
  ggplot(aes(x = TotalSeqs)) + 
  geom_histogram(bins = 50) + 
  scale_x_continuous(limits = c(0, 50000)) + 
  labs(title = "Scaled Sequencing Depth at 10137") + 
  theme_classic()
```

# Cacluate & Visualize community dissimilarity 

Exploratory analyses from Paliy & Shankar (2016) paper, which is using unconstrained ordination methods like PCoA. 

## PCoA 

### Sorensen
```{r sorensen-PCoA}
# Calculate sorensen dissimilarity: Abundance-unweighted of shared taxa
scaled_soren_pcoa <-  
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "PCoA",
    distance = "bray", binary = TRUE)

#str(scaled_soren_pcoa)

# Plot the ordination 
soren_treatment_pcoa <- plot_ordination(
  physeq = scaled_rooted_physeq,
  ordination = scaled_soren_pcoa,
  color = "treatment",
 # shape = "sample_type",
  title = "Sorensen PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = treatment)) +
  #scale_shape_manual(values = c(15,16,17,18, 19, 20)) +
  scale_color_manual(values = treatment_colors) + 
  theme_bw()
# Show the plot 
soren_treatment_pcoa
```


### Bray
```{r bray-PCoA}
# Calculate the BC distance
scaled_BC_pcoa <- 
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "PCoA",
    distance = "bray")

# Plot the PCoA
bray_treatment_pcoa <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_BC_pcoa,
    color = "treatment",
    #shape = "treatment",
    title = "Bray-Curtis PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = treatment)) +
  #scale_shape_manual(values = c(15,16,17,18, 19, 20)) +
  scale_color_manual(values = c(treatment_colors)) + 
  theme_bw()
bray_treatment_pcoa
```


### Weighted Unifrac
```{r wUnifrac-PCoA}
# Calculate the BC distance
scaled_wUNI_pcoa <- 
  ordinate(physeq = scaled_rooted_physeq,
    method = "PCoA",
    distance = "wunifrac")

str(scaled_wUNI_pcoa)

# Plot the PCoA
wUNI_treatment_pcoa <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_wUNI_pcoa,
    color = "treatment",
    shape = "treatment",
    title = "Weighted Unifrac PCoA") +
  geom_point(size=5, alpha = 0.5, aes(color = treatment)) +
  scale_shape_manual(values = c(15,16,17,18, 19, 20)) +
  scale_color_manual(values = c(treatment_colors)) + 
  theme_bw()
wUNI_treatment_pcoa
```


## Combine PCoAs

Let's plot all three together into one plot to have a concise visualization of the three metrics. 
```{r pcoa-together, fig.width=8, fig.height=3.5}
(soren_station_pcoa + theme(legend.position = "none")) + 
  (bray_station_pcoa + theme(legend.position = "none")) + 
    (wUNI_station_pcoa + theme(legend.position = "none"))
```

## NMDS 

### Weighted Unifrac

Since we did 3 of the dissimilarity metrics for the PCoA, let's just plot one example of them for the NMDS plotting. Here, we will use weighted Unifrac 
```{r wUnifrac-NMDS}
# Calculate the Weighted Unifrac distance
scaled_wUNI_nmds <- 
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "NMDS",
    distance = "wunifrac")

# Plot the PCoA
wUNI_treatment_nmds <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_wUNI_nmds,
    color = "treatment",
    shape = "treatment",
    title = "Weighted Unifrac NMDS") +
  geom_point(size=5, alpha = 0.5, aes(color = treatment)) +
  scale_shape_manual(values = c(15,16,17,18, 19, 20)) +
  scale_color_manual(values = c(treatment_colors)) + 
  theme_bw()
wUNI_treatment_nmds
```

## Combine PCoAs

Let's plot all three together into one plot to have a concise visualization of the three metrics. 
```{r pcoa-together, fig.width=8, fig.height=3.5}
(soren_treatment_pcoa + theme(legend.position = "none")) + 
  (bray_treatment_pcoa + theme(legend.position = "none")) + 
    (wUNI_treatment_pcoa + theme(legend.position = "none"))
```

## NMDS 

### Weighted Unifrac

Since we did 3 of the dissimilarity metrics for the PCoA, let's just plot one example of them for the NMDS plotting. Here, we will use weighted Unifrac 
```{r wUnifrac-NMDS}
# Calculate the Weighted Unifrac distance
scaled_wUNI_nmds <- 
  ordinate(
    physeq = scaled_rooted_physeq,
    method = "NMDS",
    distance = "wunifrac")

# Plot the PCoA
wUNI_treatment_nmds <- 
  plot_ordination(
    physeq = scaled_rooted_physeq,
    ordination = scaled_wUNI_nmds,
    color = "treatment",
    shape = "treatment",
    title = "Weighted Unifrac NMDS") +
  geom_point(size=5, alpha = 0.5, aes(color = treatment)) +
  #scale_shape_manual(values = c(15,16,17,18, 19, 20)) +
  scale_color_manual(values = c(treatment_colors)) + 
  theme_bw()
wUNI_treatment_nmds
```

```{r combined-wUnifrac, fig.width=6, fig.height=3.5}
(wUNI_station_pcoa + theme(legend.position = "none")) + 
  (wUNI_station_nmds + theme(legend.position = "none"))
```


# Statistical Significance Testing 

## PERMANOVA 
```{r PERMANOVA}
# Calculate all three of the distance matrices
scaled_sorensen_dist <- phyloseq::distance(scaled_rooted_physeq, method = "bray", binary = TRUE)
scaled_bray_dist <- phyloseq::distance(scaled_rooted_physeq, method = "bray")
scaled_wUnifrac_dist <- phyloseq::distance(scaled_rooted_physeq, method = "wunifrac")

# make a data frame from the sample_data
# All distance matrices will be the same metadata because they 
# originate from the same phyloseq object. 
metadata <- data.frame(sample_data(scaled_rooted_physeq))

# Adonis test
# In this example we are testing the hypothesis that the five stations
# that were collected have different centroids in the ordination space 
# for each of the dissimilarity metrics, we are using a discrete variable 
adonis2(scaled_sorensen_dist ~ station, data = metadata)
adonis2(scaled_bray_dist ~ station, data = metadata)
adonis2(scaled_wUnifrac_dist ~ station, data = metadata)
```


```{r PERMANOVA-multiVariable}
# We might also care about other variables
# Here, we will add date and fraction as variables
# multiplicative model ORDER MATTERS! 
adonis2(scaled_sorensen_dist ~ station * date * fraction, data = metadata)
adonis2(scaled_bray_dist ~ station * date * fraction, data = metadata)
# Note that the ORDER MATTERS!
adonis2(scaled_wUnifrac_dist ~ station * date * fraction, data = metadata)
adonis2(scaled_wUnifrac_dist ~ date * station * fraction, data = metadata)
```

We can also run tests that include additive (+) or multipliciatve models, which include the interaction term between variables. 

## BetaDispR

The PERMANOVA is sensitive to variance/dispersion in the data. Therefore, we need to run a homogeneity of dispersion test to test for the sensitivity of our PERMANOVA results to variance. 
```{r betadispR}
# Homogeneity of Disperson test with beta dispr
# Sorensen 
beta_soren_station <- betadisper(scaled_sorensen_dist, metadata$station)
permutest(beta_soren_station)

# Bray-curtis 
beta_bray_station <- betadisper(scaled_bray_dist, metadata$station)
permutest(beta_bray_station)

# Weighted Unifrac 
beta_bray_station <- betadisper(scaled_wUnifrac_dist, metadata$station)
permutest(beta_bray_station)
```

Above, our variance is impacted by station. Therefore, we need to be very careful about what we conclude about our data. 

# Session Information 
For reproducibility 
```{r session_info}
devtools::session_info()
```
